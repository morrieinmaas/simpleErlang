# Concurrency in Erlang

---

### Homework Exercise 2

*Moritz Schlichting*

*2349638s*

*Feb 22, 2018*

## Introduction
Concurrency has become evermore important for modern computer programs.
That is due to the fact that resources have become more shared and 
tasks exceedingly require parallelization. Applications range from 
messaging apps like WhatsApp, database applications and telephone switches.
The latter case provides a leading example. The Erlang language has been developed 
by the Swedish IT company Ericsson in the 1980s for exactly this purpose.
They needed a language that guarantees incredible up-time whilst handling thousands
of processes at the same time, namely telephone switches. 

In this exercise, the actor model of the Erlang language was explored in order to
implement the following:

* A clock that periodically sends messages to 2 sensors,
* 2 sensors that "measure" a temperature,
* a temperature converter from Celsius to Fahrenheit and
* an interface to perceive the converted temperatures,

as defined in th exercise description. The next section will describe its 
implementation.

## Implementation

In order to achieve the aforementioned functionality, the actor model of Erlang 
has been exploited. That is, every object or rather process can be spawned with an Id.
Further, every spawned process has a mailbox to receive messages and can send 
messages to other processes. Hence, processes can communicate. Every actor has 
been implemented as a module^[Please, see actual code provided in
the appendix]. 

First, the temperature converter was created. It takes a tuple {*char*, *int*} as an
input. If *char* equals c the *int* is converted from Celsius to Fahrenheit and if
*char8 equals F the conversion is performed the other way around. Guards are used
to match these patterns. If the pattern is not matched the underscore wildcard 
ensures that an "error" message is returned instead. 

Second, the sensors wait for a message from the clock - a tick. Once this message 
arrives they send a message to the converter, which returns the converted temperature.
This converted message is then returned to the interface, which in this case is the
terminal/Erlang shell and printed. The temperature, instead of being an actual 
measured signal, is a random number generated by the system at every iteration.

Third, the clock simply sends a tick message to the sensors every second. This is 
achieved by a recursive loop running indefinitely. A message is sent, then the funciton 
is told to sleep for 950 milliseconds, before calling itself again. This was found to be
a simple and good rough estimate to ensure roughly every second a message is sent 
whilst ttring to take into account that the communication between th actors 
takes some milliseconds as well. This required improvement in the case that the 
tick messages would require to be send a s precise as possible. 

The original idea was to implement a server client model and the clock acts as a server.
However, it only really interacts with the sensors, which handle interaction with the 
converter and pasing to the interface via io:format themselves. So, in a way they are 
servers themselves with the converter as their client, although they depend
on the input from the actual server, the clock. 

In order to bring all these functions together, all processes are spawned with 
a process Id so that they can reach each other. The modules need to be 
loaded with c(*module). from the shell to be available. Then the main function
spawning all the processes and running the infinite loop needs to be called.
The described functionalities are performed on receive of the according 
messages and the results are communicated
by sending them to another process. The exception is the clock. It runs a periodic task,
namely the tick, and sends it to the sensors. Hence, it is the true server. It acts on
its own account not based on the input of another. 

## Summary
Erlang's actor model with a simple server client structure was implemented. Conceptually,
the idea was rather straight forward. The implementation, however, was even for this 
simple scenario quite tricky with no Erlang experience at hand. The result is a 
slight oversimplification of a good solution to the problem. It was very interesting, though, 
to gain an insight into Erlang. There are several possible future improvements. 
The clock's periodic job is only a rough estimate and a different approach is required
to ensure that the job is actually executed every second. The sensor temperature could either 
be an actual measurement or parsed from a list instead. The system also does not 
implement any error handling like try/catch clauses. Also, the processes or rather their IDs
are not generic. The setup only works for this specific case when the mudoles get spawned
as done in the server:start() method. This is not as moduar as it could be. 
Lastly, the interface is not an actual interface. Two possible solutions here could be either
bindings to a GUI written in C# or similar or parsing the message to a web interface via JavaScript. 
In conclusion, Erlang was not easy, but easy enough to pick up for this task as well as quite rewarding. 
Conceptually, the actor model makes a lot of sense, yet the implementation, especially 
in this functional style was challenging and exciting.  
